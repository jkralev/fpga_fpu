-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_FPU\ise_project_fpu\Handle_Timer_Event.vhd
-- Created: 2013-02-23 10:31:21
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Handle_Timer_Event
-- Source Path: analog_mod/Handle_Timer_Event
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.analog_mod_pkg.ALL;

ENTITY Handle_Timer_Event IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        DAC_Param                         :   IN    std_logic_vector(0 TO 31);  -- boolean [32]
        Sub_en                            :   IN    std_logic;
        spi_in                            :   IN    std_logic;
        DAC_CS                            :   OUT   std_logic;
        SPI_clock                         :   OUT   std_logic;
        SPI_mosi                          :   OUT   std_logic;
        adc_data1                         :   OUT   std_logic_vector(0 TO 13);  -- boolean [14]
        adc_data2                         :   OUT   std_logic_vector(0 TO 13);  -- boolean [14]
        AD_CONV                           :   OUT   std_logic
        );
END Handle_Timer_Event;


ARCHITECTURE rtl OF Handle_Timer_Event IS

  -- Signals
  SIGNAL is_Handle_Timer_Event            : T_state_type_is_Handle_Timer_Event;  -- uint8
  SIGNAL ind1                             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL DAC_CS_reg                       : std_logic;
  SIGNAL SPI_clock_reg                    : std_logic;
  SIGNAL SPI_mosi_reg                     : std_logic;
  SIGNAL adc_data1_reg                    : std_logic_vector(0 TO 13);  -- boolean [14]
  SIGNAL adc_data2_reg                    : std_logic_vector(0 TO 13);  -- boolean [14]
  SIGNAL AD_CONV_reg                      : std_logic;
  SIGNAL is_Handle_Timer_Event_next       : T_state_type_is_Handle_Timer_Event;  -- enumerated type (21 enums)
  SIGNAL ind1_next                        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL DAC_CS_reg_next                  : std_logic;
  SIGNAL SPI_clock_reg_next               : std_logic;
  SIGNAL SPI_mosi_reg_next                : std_logic;
  SIGNAL adc_data1_reg_next               : std_logic_vector(0 TO 13);  -- boolean [14]
  SIGNAL adc_data2_reg_next               : std_logic_vector(0 TO 13);  -- boolean [14]
  SIGNAL AD_CONV_reg_next                 : std_logic;

BEGIN
  Handle_Timer_Event_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      ind1 <= to_unsigned(0, 8);
      DAC_CS_reg <= '1';
      SPI_clock_reg <= '0';
      SPI_mosi_reg <= '0';
      adc_data1_reg <= (OTHERS => '0');
      adc_data2_reg <= (OTHERS => '0');
      AD_CONV_reg <= '0';
      is_Handle_Timer_Event <= IN_Led_is_Off;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_Handle_Timer_Event <= is_Handle_Timer_Event_next;
        ind1 <= ind1_next;
        DAC_CS_reg <= DAC_CS_reg_next;
        SPI_clock_reg <= SPI_clock_reg_next;
        SPI_mosi_reg <= SPI_mosi_reg_next;
        adc_data1_reg <= adc_data1_reg_next;
        adc_data2_reg <= adc_data2_reg_next;
        AD_CONV_reg <= AD_CONV_reg_next;
      END IF;
    END IF;
  END PROCESS Handle_Timer_Event_1_process;

  Handle_Timer_Event_1_output : PROCESS (is_Handle_Timer_Event, DAC_Param, ind1, Sub_en, spi_in, DAC_CS_reg, SPI_clock_reg, 
      SPI_mosi_reg, adc_data1_reg, adc_data2_reg, AD_CONV_reg)
    VARIABLE sub_cast : signed(8 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(8 DOWNTO 0);
  BEGIN
    is_Handle_Timer_Event_next <= is_Handle_Timer_Event;
    ind1_next <= ind1;
    DAC_CS_reg_next <= DAC_CS_reg;
    SPI_clock_reg_next <= SPI_clock_reg;
    SPI_mosi_reg_next <= SPI_mosi_reg;
    adc_data1_reg_next <= adc_data1_reg;
    adc_data2_reg_next <= adc_data2_reg;
    AD_CONV_reg_next <= AD_CONV_reg;

    CASE is_Handle_Timer_Event IS
      WHEN IN_AD_Start =>
        AD_CONV_reg_next <= '1';
        is_Handle_Timer_Event_next <= IN_Wait9;
      WHEN IN_Led_is_Off =>
        IF Sub_en = '1' THEN 
          DAC_CS_reg_next <= '0';
          ind1_next <= to_unsigned(0, 8);
          is_Handle_Timer_Event_next <= IN_Led_is_On;
        END IF;
      WHEN IN_Led_is_On =>
        IF ind1 < 32 THEN 
          SPI_mosi_reg_next <= DAC_Param(to_integer(ind1));
          is_Handle_Timer_Event_next <= IN_Wait1;
        ELSE 
          DAC_CS_reg_next <= '1';
          is_Handle_Timer_Event_next <= IN_AD_Start;
        END IF;
      WHEN IN_Wait1 =>
        SPI_clock_reg_next <= '1';
        is_Handle_Timer_Event_next <= IN_Wait7;
      WHEN IN_Wait10 =>
        is_Handle_Timer_Event_next <= IN_Wait17;
      WHEN IN_Wait11 =>
        is_Handle_Timer_Event_next <= IN_Wait15;
      WHEN IN_Wait12 =>
        IF ind1 > 1 THEN 
          sub_cast := signed(resize(ind1, 9));
          adc_data1_reg_next(to_integer(sub_cast - 2)) <= spi_in;
          is_Handle_Timer_Event_next <= IN_Wait14;
        END IF;
      WHEN IN_Wait14 =>
        IF ind1 < 15 THEN 
          SPI_clock_reg_next <= '1';
          is_Handle_Timer_Event_next <= IN_Wait11;
        ELSE 
          SPI_clock_reg_next <= '1';
          ind1_next <= to_unsigned(0, 8);
          is_Handle_Timer_Event_next <= IN_Wait18;
        END IF;
      WHEN IN_Wait15 =>
        SPI_clock_reg_next <= '0';
        ind1_next <= ind1 + 1;
        is_Handle_Timer_Event_next <= IN_Wait12;
      WHEN IN_Wait17 =>
        SPI_clock_reg_next <= '1';
        is_Handle_Timer_Event_next <= IN_Wait11;
      WHEN IN_Wait18 =>
        is_Handle_Timer_Event_next <= IN_Wait21;
      WHEN IN_Wait19 =>
        IF ind1 > 1 THEN 
          sub_cast_0 := signed(resize(ind1, 9));
          adc_data2_reg_next(to_integer(sub_cast_0 - 2)) <= spi_in;
          is_Handle_Timer_Event_next <= IN_Wait20;
        END IF;
      WHEN IN_Wait20 =>
        IF ind1 < 15 THEN 
          SPI_clock_reg_next <= '1';
          is_Handle_Timer_Event_next <= IN_Wait18;
        ELSE 
          SPI_clock_reg_next <= '1';
          is_Handle_Timer_Event_next <= IN_Wait22;
        END IF;
      WHEN IN_Wait21 =>
        SPI_clock_reg_next <= '0';
        ind1_next <= ind1 + 1;
        is_Handle_Timer_Event_next <= IN_Wait19;
      WHEN IN_Wait22 =>
        SPI_clock_reg_next <= '0';
        is_Handle_Timer_Event_next <= IN_Wait23;
      WHEN IN_Wait23 =>
        SPI_clock_reg_next <= '1';
        is_Handle_Timer_Event_next <= IN_Wait24;
      WHEN IN_Wait24 =>
        SPI_clock_reg_next <= '0';
        is_Handle_Timer_Event_next <= IN_Wait25;
      WHEN IN_Wait25 =>
        is_Handle_Timer_Event_next <= IN_Led_is_Off;
      WHEN IN_Wait3 =>
        IF ind1 < 32 THEN 
          SPI_mosi_reg_next <= DAC_Param(to_integer(ind1));
          is_Handle_Timer_Event_next <= IN_Wait1;
        ELSE 
          DAC_CS_reg_next <= '1';
          is_Handle_Timer_Event_next <= IN_AD_Start;
        END IF;
      WHEN IN_Wait7 =>
        ind1_next <= ind1 + 1;
        SPI_clock_reg_next <= '0';
        is_Handle_Timer_Event_next <= IN_Wait3;
      WHEN IN_Wait9 =>
        AD_CONV_reg_next <= '0';
        ind1_next <= to_unsigned(0, 8);
        is_Handle_Timer_Event_next <= IN_Wait10;
      WHEN OTHERS => 
        is_Handle_Timer_Event_next <= IN_Led_is_Off;
    END CASE;

  END PROCESS Handle_Timer_Event_1_output;

  DAC_CS <= DAC_CS_reg_next;
  SPI_clock <= SPI_clock_reg_next;
  SPI_mosi <= SPI_mosi_reg_next;
  adc_data1 <= adc_data1_reg_next;
  adc_data2 <= adc_data2_reg_next;
  AD_CONV <= AD_CONV_reg_next;

END rtl;

