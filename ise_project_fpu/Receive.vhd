-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_Test\ise_project_1\Receive.vhd
-- Created: 2012-11-02 14:15:17
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Receive
-- Source Path: test_rx/Receive
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.test_rx_pkg.ALL;

ENTITY Receive IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        next_rdy                          :   IN    std_logic;
        RX_DV                             :   IN    std_logic;
        data_in                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        RX_ER                             :   IN    std_logic;
        RX_CLK                            :   IN    std_logic;
        Data                              :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        ind1                              :   OUT   std_logic_vector(10 DOWNTO 0);  -- ufix11
        put_next                          :   OUT   std_logic;
        ram_en                            :   OUT   std_logic;
        read_ev                           :   OUT   std_logic
        );
END Receive;


ARCHITECTURE rtl OF Receive IS

  -- Signals
  SIGNAL data_in_unsigned                 : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL is_Receive                       : T_state_type_is_Receive;  -- uint8
  SIGNAL Data_tmp                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL ind1_tmp                         : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL buf_rx                           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Pack_on_line                     : std_logic;
  SIGNAL Data_reg                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL ind1_reg                         : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL put_next_reg                     : std_logic;
  SIGNAL ram_en_reg                       : std_logic;
  SIGNAL read_ev_reg                      : std_logic;
  SIGNAL is_Receive_next                  : T_state_type_is_Receive;  -- enumerated type (9 enums)
  SIGNAL buf_rx_next                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Pack_on_line_next                : std_logic;
  SIGNAL Data_reg_next                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL ind1_reg_next                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL put_next_reg_next                : std_logic;
  SIGNAL ram_en_reg_next                  : std_logic;
  SIGNAL read_ev_reg_next                 : std_logic;

BEGIN
  data_in_unsigned <= unsigned(data_in);

  Receive_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      buf_rx <= to_unsigned(0, 8);
      Pack_on_line <= '0';
      Data_reg <= to_unsigned(0, 8);
      ind1_reg <= to_unsigned(0, 11);
      put_next_reg <= '0';
      ram_en_reg <= '0';
      read_ev_reg <= '0';
      is_Receive <= IN_Start_RX;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_Receive <= is_Receive_next;
        buf_rx <= buf_rx_next;
        Pack_on_line <= Pack_on_line_next;
        Data_reg <= Data_reg_next;
        ind1_reg <= ind1_reg_next;
        put_next_reg <= put_next_reg_next;
        ram_en_reg <= ram_en_reg_next;
        read_ev_reg <= read_ev_reg_next;
      END IF;
    END IF;
  END PROCESS Receive_1_process;

  Receive_1_output : PROCESS (is_Receive, next_rdy, buf_rx, Pack_on_line, RX_DV, data_in_unsigned, RX_ER, RX_CLK, 
      Data_reg, ind1_reg, put_next_reg, ram_en_reg, read_ev_reg)
    VARIABLE buf1 : unsigned(7 DOWNTO 0);
    VARIABLE buf_rx_temp : unsigned(7 DOWNTO 0);
  BEGIN
    buf_rx_temp := buf_rx;
    is_Receive_next <= is_Receive;
    Pack_on_line_next <= Pack_on_line;
    Data_reg_next <= Data_reg;
    ind1_reg_next <= ind1_reg;
    put_next_reg_next <= put_next_reg;
    ram_en_reg_next <= ram_en_reg;
    read_ev_reg_next <= read_ev_reg;

    CASE is_Receive IS
      WHEN IN_Error =>
        IF RX_DV = '0' THEN 
          Pack_on_line_next <= '0';
          is_Receive_next <= IN_Start_RX;
        END IF;
      WHEN IN_Read =>
        IF RX_CLK = '0' THEN 
          buf_rx_temp := data_in_unsigned;
          is_Receive_next <= IN_Wait1;
        END IF;
      WHEN IN_Read_rdy =>
        read_ev_reg_next <= '0';
        Data_reg_next <= to_unsigned(0, 8);
        is_Receive_next <= IN_Read_rdy1;
      WHEN IN_Read_rdy1 =>
        IF RX_DV = '0' THEN 
          is_Receive_next <= IN_Start_RX;
        END IF;
      WHEN IN_Start_RX =>
        IF RX_CLK = '1' THEN 
          put_next_reg_next <= '0';
          is_Receive_next <= IN_Wait_low;
        END IF;
      WHEN IN_Wait1 =>
        IF RX_CLK = '1' THEN 
          is_Receive_next <= IN_Wait2;
        END IF;
      WHEN IN_Wait2 =>
        IF RX_CLK = '0' THEN 
          buf1 := data_in_unsigned sll 4;
          buf_rx_temp := resize(resize(buf_rx, 9) OR resize(buf1, 9), 8);
          put_next_reg_next <= '1';
          ram_en_reg_next <= '1';
          Data_reg_next <= buf_rx_temp;
          is_Receive_next <= IN_WriteRAM;
        END IF;
      WHEN IN_Wait_low =>
        IF RX_CLK = '0' THEN 
          put_next_reg_next <= '0';
          IF RX_DV = '1' THEN 
            put_next_reg_next <= '0';
            IF RX_ER = '1' THEN 
              is_Receive_next <= IN_Error;
            ELSIF Pack_on_line = '0' THEN 
              Pack_on_line_next <= '1';
              put_next_reg_next <= '0';
              ind1_reg_next <= to_unsigned(0, 11);
              is_Receive_next <= IN_Read;
            ELSE 
              is_Receive_next <= IN_Read;
            END IF;
          ELSE 
            is_Receive_next <= IN_Start_RX;
          END IF;
        END IF;
      WHEN IN_WriteRAM =>
        IF next_rdy = '1' THEN 
          put_next_reg_next <= '0';
          ram_en_reg_next <= '0';
          IF ind1_reg < 64 THEN 
            ind1_reg_next <= ind1_reg + 1;
            is_Receive_next <= IN_Start_RX;
          ELSE 
            Pack_on_line_next <= '0';
            read_ev_reg_next <= '1';
            ind1_reg_next <= to_unsigned(0, 11);
            is_Receive_next <= IN_Read_rdy;
          END IF;
        END IF;
      WHEN OTHERS => 
        is_Receive_next <= IN_Start_RX;
    END CASE;

    buf_rx_next <= buf_rx_temp;
  END PROCESS Receive_1_output;

  Data_tmp <= Data_reg_next;
  ind1_tmp <= ind1_reg_next;
  put_next <= put_next_reg_next;
  ram_en <= ram_en_reg_next;
  read_ev <= read_ev_reg_next;

  Data <= std_logic_vector(Data_tmp);

  ind1 <= std_logic_vector(ind1_tmp);

END rtl;

