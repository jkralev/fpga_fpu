-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_FPU\ise_project_fpu\Convert_Integer_to_Single.vhd
-- Created: 2013-02-23 10:31:21
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Convert_Integer_to_Single
-- Source Path: analog_mod/Convert Integer to Single
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.analog_mod_pkg.ALL;

ENTITY Convert_Integer_to_Single IS
  PORT( u                                 :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14
        y                                 :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END Convert_Integer_to_Single;


ARCHITECTURE rtl OF Convert_Integer_to_Single IS

  -- Signals
  SIGNAL u_signed                         : signed(13 DOWNTO 0);  -- sfix14
  SIGNAL y_tmp                            : unsigned(31 DOWNTO 0);  -- uint32

BEGIN
  u_signed <= signed(u);

  Convert_Integer_to_Single_1_output : PROCESS (u_signed)
    VARIABLE sig : unsigned(7 DOWNTO 0);
    VARIABLE exp : unsigned(7 DOWNTO 0);
    VARIABLE frac : unsigned(22 DOWNTO 0);
    VARIABLE buf : signed(13 DOWNTO 0);
    VARIABLE frac1 : unsigned(22 DOWNTO 0);
    VARIABLE buf1 : unsigned(23 DOWNTO 0);
    VARIABLE p : unsigned(4 DOWNTO 0);
    VARIABLE z : unsigned(31 DOWNTO 0);
    VARIABLE buf2 : unsigned(31 DOWNTO 0);
    VARIABLE iA : unsigned(7 DOWNTO 0);
    VARIABLE x : unsigned(23 DOWNTO 0);
    VARIABLE y1 : unsigned(23 DOWNTO 0);
    VARIABLE y_0 : unsigned(23 DOWNTO 0);
    VARIABLE droppedBits : unsigned(23 DOWNTO 0);
    VARIABLE c_uint : unsigned(23 DOWNTO 0);
    VARIABLE c_uint_0 : unsigned(23 DOWNTO 0);
    VARIABLE y_1 : unsigned(23 DOWNTO 0);
    VARIABLE droppedbits_0 : unsigned(23 DOWNTO 0);
    VARIABLE p_0 : unsigned(4 DOWNTO 0);
    VARIABLE z_0 : unsigned(31 DOWNTO 0);
    VARIABLE t_0 : signed(14 DOWNTO 0);
    VARIABLE add_cast : unsigned(9 DOWNTO 0);
    VARIABLE add_cast_0 : unsigned(10 DOWNTO 0);
    VARIABLE add_temp : unsigned(10 DOWNTO 0);
    VARIABLE cast : unsigned(9 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_temp : signed(31 DOWNTO 0);
    VARIABLE cast_0 : signed(7 DOWNTO 0);
    VARIABLE add_cast_1 : vector_of_unsigned10(0 TO 22);
    VARIABLE add_cast_2 : vector_of_unsigned11(0 TO 22);
    VARIABLE add_temp_0 : vector_of_unsigned11(0 TO 22);
    VARIABLE cast_1 : vector_of_unsigned10(0 TO 22);
    VARIABLE sub_cast_0 : signed(6 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(6 DOWNTO 0);
    VARIABLE add_cast_3 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(8 DOWNTO 0);
  BEGIN
    --Transform two's complement integer into unnormalized
    --single number
    IF u_signed > 0 THEN 
      sig := to_unsigned(0, 8);
      IF u_signed(13) = '1' THEN 
        frac1 := "00000000000000000000000";
      ELSE 
        frac1 := unsigned(resize(u_signed, 23));
      END IF;
    ELSE 
      sig := to_unsigned(1, 8);
      t_0 :=  - (resize(u_signed, 15));
      IF (t_0(14) = '0') AND (t_0(13) /= '0') THEN 
        buf := "01111111111111";
      ELSIF (t_0(14) = '1') AND (t_0(13) /= '1') THEN 
        buf := "10000000000000";
      ELSE 
        buf := t_0(13 DOWNTO 0);
      END IF;
      IF buf(13) = '1' THEN 
        frac1 := "00000000000000000000000";
      ELSE 
        frac1 := unsigned(resize(buf, 23));
      END IF;
    END IF;
    --Normalize floating-point number
    buf1 := resize(frac1, 24);
    p := to_unsigned(0, 5);

    FOR ind IN 0 TO 22 LOOP
      c_uint_0 := buf1 AND to_unsigned(4194304, 24);
      IF c_uint_0 = 0 THEN 
        droppedbits_0 := buf1 srl 23;
        IF droppedbits_0 = 0 THEN 
          y_1 := buf1 sll 1;
        ELSE 
          y_1 :=  NOT to_unsigned(0, 24);
        END IF;
        buf1 := y_1;
        add_cast_1(ind) := resize(p & '0' & '0' & '0' & '0', 10);
        add_cast_2(ind) := resize(add_cast_1(ind), 11);
        add_temp_0(ind) := add_cast_2(ind) + 16;
        IF add_temp_0(ind)(10) /= '0' THEN 
          cast_1(ind) := "1111111111";
        ELSE 
          cast_1(ind) := add_temp_0(ind)(9 DOWNTO 0);
        END IF;
        IF (cast_1(ind)(9) /= '0') OR ((cast_1(ind)(9) = '0') AND (cast_1(ind)(8 DOWNTO 4) = "11111")) THEN 
          p := "11111";
        ELSE 
          p := cast_1(ind)(8 DOWNTO 4) + ("0" & cast_1(ind)(3));
        END IF;
      END IF;
    END LOOP;

    add_cast := resize(p & '0' & '0' & '0' & '0', 10);
    add_cast_0 := resize(add_cast, 11);
    add_temp := add_cast_0 + 16;
    IF add_temp(10) /= '0' THEN 
      cast := "1111111111";
    ELSE 
      cast := add_temp(9 DOWNTO 0);
    END IF;
    IF (cast(9) /= '0') OR ((cast(9) = '0') AND (cast(8 DOWNTO 4) = "11111")) THEN 
      p_0 := "11111";
    ELSE 
      p_0 := cast(8 DOWNTO 4) + ("0" & cast(3));
    END IF;
    iA := resize(p_0, 8);
    x := resize(frac1, 24);
    IF iA > 0 THEN 
      IF iA >= 24 THEN 
        droppedBits := x;
        iA := to_unsigned(0, 8);
      ELSE 
        sub_cast := signed(resize(iA, 32));
        sub_temp := 24 - sub_cast;
        cast_0 := sub_temp(7 DOWNTO 0);
        droppedBits := x srl to_integer(cast_0);
      END IF;
      IF droppedBits = 0 THEN 
        y_0 := x sll to_integer(iA);
      ELSE 
        y_0 :=  NOT to_unsigned(0, 24);
      END IF;
      y1 := y_0;
    ELSE 
      y1 := x;
    END IF;
    c_uint := y1 AND to_unsigned(8388607, 24);
    IF c_uint(23) /= '0' THEN 
      frac := "11111111111111111111111";
    ELSE 
      frac := c_uint(22 DOWNTO 0);
    END IF;
    sub_cast_0 := signed(resize(p_0, 7));
    sub_temp_0 := 22 - sub_cast_0;
    add_cast_3 := unsigned(resize(sub_temp_0, 9));
    add_temp_1 := 128 + add_cast_3;
    IF add_temp_1(8) /= '0' THEN 
      exp := "11111111";
    ELSE 
      exp := add_temp_1(7 DOWNTO 0);
    END IF;
    --Compose floating-point number
    z := to_unsigned(0, 32);
    IF sig /= 0 THEN 
      z := unsigned'("10000000000000000000000000000000");
    END IF;
    buf2 := resize(exp, 32) sll 23;
    z_0 := z OR buf2;
    y_tmp <= z_0 OR resize(frac, 32);
  END PROCESS Convert_Integer_to_Single_1_output;


  y <= std_logic_vector(y_tmp);

END rtl;

