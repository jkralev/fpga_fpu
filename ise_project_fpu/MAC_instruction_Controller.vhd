-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_Test\ise_project_1\MAC_instruction_Controller.vhd
-- Created: 2012-11-04 23:05:06
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: MAC_instruction_Controller
-- Source Path: ss_controller/Fixed state space FPGA controller/MAC instruction Controller
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ss_controller_pkg.ALL;

ENTITY MAC_instruction_Controller IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        sys                               :   IN    vector_of_std_logic_vector32(0 TO 194);  -- sfix32_En16 [195]
        xu                                :   IN    vector_of_std_logic_vector32(0 TO 14);  -- sfix32_En16 [15]
        result                            :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        Model_Tick                        :   IN    std_logic;
        mul1                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        mul2                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        reset_1                           :   OUT   std_logic;
        xy                                :   OUT   vector_of_std_logic_vector32(0 TO 12)  -- sfix32_En16 [13]
        );
END MAC_instruction_Controller;


ARCHITECTURE rtl OF MAC_instruction_Controller IS

  -- Signals
  SIGNAL sys_signed                       : vector_of_signed32(0 TO 194);  -- sfix32_En16 [195]
  SIGNAL xu_signed                        : vector_of_signed32(0 TO 14);  -- sfix32_En16 [15]
  SIGNAL result_signed                    : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL is_MAC_instruction_Controller    : T_state_type_is_MAC_instruction_Controller;  -- uint8
  SIGNAL row                              : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL col                              : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL mul1_tmp                         : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL mul2_tmp                         : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL xy_tmp                           : vector_of_signed32(0 TO 12);  -- sfix32_En16 [13]
  SIGNAL xy_buf                           : vector_of_signed32(0 TO 12);  -- sfix32_En16 [13]
  SIGNAL mul1_reg                         : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL mul2_reg                         : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL reset_reg                        : std_logic;
  SIGNAL xy_reg                           : vector_of_signed32(0 TO 12);  -- sfix32_En16 [13]
  SIGNAL is_MAC_instruction_Controller_next : T_state_type_is_MAC_instruction_Controller;  -- enumerated type (4 enums)
  SIGNAL row_next                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL col_next                         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL xy_buf_next                      : vector_of_signed32(0 TO 12);  -- sfix32_En16 [13]
  SIGNAL mul1_reg_next                    : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL mul2_reg_next                    : signed(31 DOWNTO 0);  -- sfix32_En16
  SIGNAL reset_reg_next                   : std_logic;
  SIGNAL xy_reg_next                      : vector_of_signed32(0 TO 12);  -- sfix32_En16 [13]

BEGIN
  outputgen2: FOR k IN 0 TO 194 GENERATE
    sys_signed(k) <= signed(sys(k));
  END GENERATE;

  outputgen1: FOR k IN 0 TO 14 GENERATE
    xu_signed(k) <= signed(xu(k));
  END GENERATE;

  result_signed <= signed(result);

  MAC_instruction_Controller_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      row <= to_unsigned(0, 8);
      col <= to_unsigned(0, 8);
      mul1_reg <= to_signed(0, 32);
      mul2_reg <= to_signed(0, 32);
      reset_reg <= '0';
      xy_buf <= (OTHERS => to_signed(0, 32));
      xy_reg <= (OTHERS => to_signed(0, 32));
      is_MAC_instruction_Controller <= IN_wait_r;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_MAC_instruction_Controller <= is_MAC_instruction_Controller_next;
        row <= row_next;
        col <= col_next;
        mul1_reg <= mul1_reg_next;
        mul2_reg <= mul2_reg_next;
        reset_reg <= reset_reg_next;
        xy_buf <= xy_buf_next;
        xy_reg <= xy_reg_next;
      END IF;
    END IF;
  END PROCESS MAC_instruction_Controller_1_process;

  MAC_instruction_Controller_1_output : PROCESS (is_MAC_instruction_Controller, sys_signed, xu_signed, row, col, result_signed, Model_Tick, 
      xy_buf, mul1_reg, mul2_reg, reset_reg, xy_reg)
  BEGIN
    col_next <= col;
    is_MAC_instruction_Controller_next <= is_MAC_instruction_Controller;
    row_next <= row;
    mul1_reg_next <= mul1_reg;
    mul2_reg_next <= mul2_reg;
    reset_reg_next <= reset_reg;
    xy_buf_next <= xy_buf;
    xy_reg_next <= xy_reg;

    CASE is_MAC_instruction_Controller IS
      WHEN IN_calcr =>
        IF col = 15 THEN 
          xy_buf_next(to_integer(row)) <= result_signed;
          row_next <= row + 1;
          col_next <= to_unsigned(0, 8);
          reset_reg_next <= '1';
          is_MAC_instruction_Controller_next <= IN_resetw;
        ELSIF row = 13 THEN 
          xy_reg_next <= xy_buf;
          is_MAC_instruction_Controller_next <= IN_wait_f;
        ELSE 
          mul1_reg_next <= sys_signed(to_integer((to_unsigned(15, 4) * row) + resize(col, 12)));
          mul2_reg_next <= xu_signed(to_integer(col));
          col_next <= col + 1;
          is_MAC_instruction_Controller_next <= IN_calcr;
        END IF;
      WHEN IN_resetw =>
        reset_reg_next <= '0';
        IF row = 13 THEN 
          xy_reg_next <= xy_buf;
          is_MAC_instruction_Controller_next <= IN_wait_f;
        ELSE 
          mul1_reg_next <= sys_signed(to_integer((to_unsigned(15, 4) * row) + resize(col, 12)));
          mul2_reg_next <= xu_signed(to_integer(col));
          col_next <= col + 1;
          is_MAC_instruction_Controller_next <= IN_calcr;
        END IF;
      WHEN IN_wait_f =>
        IF Model_Tick = '0' THEN 
          is_MAC_instruction_Controller_next <= IN_wait_r;
        END IF;
      WHEN IN_wait_r =>
        IF Model_Tick = '1' THEN 
          row_next <= to_unsigned(0, 8);
          mul1_reg_next <= sys_signed(0);
          mul2_reg_next <= xu_signed(0);
          col_next <= to_unsigned(1, 8);
          is_MAC_instruction_Controller_next <= IN_calcr;
        END IF;
      WHEN OTHERS => 
        is_MAC_instruction_Controller_next <= IN_wait_r;
    END CASE;

  END PROCESS MAC_instruction_Controller_1_output;

  mul1_tmp <= mul1_reg_next;
  mul2_tmp <= mul2_reg_next;
  reset_1 <= reset_reg_next;
  xy_tmp <= xy_reg_next;

  mul1 <= std_logic_vector(mul1_tmp);

  mul2 <= std_logic_vector(mul2_tmp);

  outputgen: FOR k IN 0 TO 12 GENERATE
    xy(k) <= std_logic_vector(xy_tmp(k));
  END GENERATE;

END rtl;

