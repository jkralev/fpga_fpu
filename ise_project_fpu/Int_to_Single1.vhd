-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_FPU\ise_project_fpu\Int_to_Single1.vhd
-- Created: 2013-04-30 17:53:18
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Int_to_Single1
-- Source Path: int2single/Int to Single1
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.int2single_pkg.ALL;

ENTITY Int_to_Single1 IS
  PORT( u                                 :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
        y                                 :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END Int_to_Single1;


ARCHITECTURE rtl OF Int_to_Single1 IS

  -- Signals
  SIGNAL u_unsigned                       : unsigned(11 DOWNTO 0);  -- ufix12
  SIGNAL y_tmp                            : unsigned(31 DOWNTO 0);  -- uint32

BEGIN
  u_unsigned <= unsigned(u);

  Int_to_Single1_1_output : PROCESS (u_unsigned)
    VARIABLE exp : unsigned(7 DOWNTO 0);
    VARIABLE frac : unsigned(22 DOWNTO 0);
    VARIABLE frac1 : unsigned(22 DOWNTO 0);
    VARIABLE buf1 : unsigned(23 DOWNTO 0);
    VARIABLE p : unsigned(4 DOWNTO 0);
    VARIABLE buf2 : unsigned(31 DOWNTO 0);
    VARIABLE iA : unsigned(7 DOWNTO 0);
    VARIABLE x : unsigned(23 DOWNTO 0);
    VARIABLE y1 : unsigned(23 DOWNTO 0);
    VARIABLE y_0 : unsigned(23 DOWNTO 0);
    VARIABLE droppedBits : unsigned(23 DOWNTO 0);
    VARIABLE c_uint : unsigned(23 DOWNTO 0);
    VARIABLE c_uint_0 : unsigned(23 DOWNTO 0);
    VARIABLE y_1 : unsigned(23 DOWNTO 0);
    VARIABLE droppedbits_0 : unsigned(23 DOWNTO 0);
    VARIABLE p_0 : unsigned(4 DOWNTO 0);
    VARIABLE add_cast : unsigned(9 DOWNTO 0);
    VARIABLE add_cast_0 : unsigned(10 DOWNTO 0);
    VARIABLE add_temp : unsigned(10 DOWNTO 0);
    VARIABLE cast : unsigned(9 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_temp : signed(31 DOWNTO 0);
    VARIABLE cast_0 : signed(7 DOWNTO 0);
    VARIABLE add_cast_1 : vector_of_unsigned10(0 TO 22);
    VARIABLE add_cast_2 : vector_of_unsigned11(0 TO 22);
    VARIABLE add_temp_0 : vector_of_unsigned11(0 TO 22);
    VARIABLE cast_1 : vector_of_unsigned10(0 TO 22);
    VARIABLE sub_cast_0 : signed(6 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(6 DOWNTO 0);
    VARIABLE add_cast_3 : unsigned(8 DOWNTO 0);
    VARIABLE add_temp_1 : unsigned(8 DOWNTO 0);
  BEGIN
    --Transform two's complement integer into unnormalized
    --single number
    frac1 := resize(u_unsigned, 23);
    --Normalize floating-point number
    buf1 := resize(frac1, 24);
    p := to_unsigned(0, 5);

    FOR ind IN 0 TO 22 LOOP
      c_uint_0 := buf1 AND to_unsigned(4194304, 24);
      IF c_uint_0 = 0 THEN 
        droppedbits_0 := buf1 srl 23;
        IF droppedbits_0 = 0 THEN 
          y_1 := buf1 sll 1;
        ELSE 
          y_1 :=  NOT to_unsigned(0, 24);
        END IF;
        buf1 := y_1;
        add_cast_1(ind) := resize(p & '0' & '0' & '0' & '0', 10);
        add_cast_2(ind) := resize(add_cast_1(ind), 11);
        add_temp_0(ind) := add_cast_2(ind) + 16;
        IF add_temp_0(ind)(10) /= '0' THEN 
          cast_1(ind) := "1111111111";
        ELSE 
          cast_1(ind) := add_temp_0(ind)(9 DOWNTO 0);
        END IF;
        IF (cast_1(ind)(9) /= '0') OR ((cast_1(ind)(9) = '0') AND (cast_1(ind)(8 DOWNTO 4) = "11111")) THEN 
          p := "11111";
        ELSE 
          p := cast_1(ind)(8 DOWNTO 4) + ("0" & cast_1(ind)(3));
        END IF;
      END IF;
    END LOOP;

    add_cast := resize(p & '0' & '0' & '0' & '0', 10);
    add_cast_0 := resize(add_cast, 11);
    add_temp := add_cast_0 + 16;
    IF add_temp(10) /= '0' THEN 
      cast := "1111111111";
    ELSE 
      cast := add_temp(9 DOWNTO 0);
    END IF;
    IF (cast(9) /= '0') OR ((cast(9) = '0') AND (cast(8 DOWNTO 4) = "11111")) THEN 
      p_0 := "11111";
    ELSE 
      p_0 := cast(8 DOWNTO 4) + ("0" & cast(3));
    END IF;
    iA := resize(p_0, 8);
    x := resize(frac1, 24);
    IF iA > 0 THEN 
      IF iA >= 24 THEN 
        droppedBits := x;
        iA := to_unsigned(0, 8);
      ELSE 
        sub_cast := signed(resize(iA, 32));
        sub_temp := 24 - sub_cast;
        cast_0 := sub_temp(7 DOWNTO 0);
        droppedBits := x srl to_integer(cast_0);
      END IF;
      IF droppedBits = 0 THEN 
        y_0 := x sll to_integer(iA);
      ELSE 
        y_0 :=  NOT to_unsigned(0, 24);
      END IF;
      y1 := y_0;
    ELSE 
      y1 := x;
    END IF;
    c_uint := y1 AND to_unsigned(8388607, 24);
    IF c_uint(23) /= '0' THEN 
      frac := "11111111111111111111111";
    ELSE 
      frac := c_uint(22 DOWNTO 0);
    END IF;
    sub_cast_0 := signed(resize(p_0, 7));
    sub_temp_0 := 22 - sub_cast_0;
    add_cast_3 := unsigned(resize(sub_temp_0, 9));
    add_temp_1 := 128 + add_cast_3;
    IF add_temp_1(8) /= '0' THEN 
      exp := "11111111";
    ELSE 
      exp := add_temp_1(7 DOWNTO 0);
    END IF;
    --Compose floating-point number
    buf2 := resize(exp, 32) sll 23;
    y_tmp <= buf2 OR resize(frac, 32);
  END PROCESS Int_to_Single1_1_output;


  y <= std_logic_vector(y_tmp);

END rtl;

