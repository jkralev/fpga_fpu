-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_FPU\ise_project_fpu\input_output_controller.vhd
-- Created: 2013-03-05 11:26:58
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: input_output_controller
-- Source Path: ivedsp/input_output_controller
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ivedsp_pkg.ALL;

ENTITY input_output_controller IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        PC_In                             :   IN    vector_of_std_logic_vector8(0 TO 3);  -- uint8 [4]
        port_rsvd                         :   IN    std_logic_vector(4 DOWNTO 0);  -- ufix5
        OUT_instr                         :   IN    std_logic;
        ADC_N                             :   IN    std_logic_vector(4 DOWNTO 0);  -- ufix5
        ind                               :   IN    std_logic_vector(4 DOWNTO 0);  -- ufix5
        write_ram                         :   OUT   std_logic;
        data_ram                          :   OUT   std_logic_vector(7 DOWNTO 0);  -- uint8
        addr_ram                          :   OUT   std_logic_vector(13 DOWNTO 0);  -- ufix14
        ready                             :   OUT   std_logic;
        DAC                               :   OUT   vector_of_std_logic_vector8(0 TO 7);  -- uint8 [8]
        ind_next                          :   OUT   std_logic_vector(4 DOWNTO 0)  -- ufix5
        );
END input_output_controller;


ARCHITECTURE rtl OF input_output_controller IS

  -- Signals
  SIGNAL PC_In_unsigned                   : vector_of_unsigned8(0 TO 3);  -- uint8 [4]
  SIGNAL port_unsigned                    : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL ADC_N_unsigned                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL ind_unsigned                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL is_input_output_controller       : T_state_type_is_input_output_controller;  -- uint8
  SIGNAL data_ram_tmp                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL addr_ram_tmp                     : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL DAC_tmp                          : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL ind_next_tmp                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL write_ram_reg                    : std_logic;
  SIGNAL data_ram_reg                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL addr_ram_reg                     : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL ready_reg                        : std_logic;
  SIGNAL DAC_reg                          : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL ind_next_reg                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL is_input_output_controller_next  : T_state_type_is_input_output_controller;  -- enumerated type (6 enums)
  SIGNAL write_ram_reg_next               : std_logic;
  SIGNAL data_ram_reg_next                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL addr_ram_reg_next                : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL ready_reg_next                   : std_logic;
  SIGNAL DAC_reg_next                     : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL ind_next_reg_next                : unsigned(4 DOWNTO 0);  -- ufix5

BEGIN
  outputgen1: FOR k IN 0 TO 3 GENERATE
    PC_In_unsigned(k) <= unsigned(PC_In(k));
  END GENERATE;

  port_unsigned <= unsigned(port_rsvd);

  ADC_N_unsigned <= unsigned(ADC_N);

  ind_unsigned <= unsigned(ind);

  input_output_controller_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      write_ram_reg <= '0';
      data_ram_reg <= to_unsigned(0, 8);
      addr_ram_reg <= to_unsigned(0, 14);
      ready_reg <= '0';

      FOR t_0 IN 0 TO 7 LOOP
        DAC_reg(t_0) <= to_unsigned(0, 8);
      END LOOP;

      ind_next_reg <= to_unsigned(0, 5);
      is_input_output_controller <= IN_Receive;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_input_output_controller <= is_input_output_controller_next;
        write_ram_reg <= write_ram_reg_next;
        data_ram_reg <= data_ram_reg_next;
        addr_ram_reg <= addr_ram_reg_next;
        ready_reg <= ready_reg_next;
        DAC_reg <= DAC_reg_next;
        ind_next_reg <= ind_next_reg_next;
      END IF;
    END IF;
  END PROCESS input_output_controller_1_process;

  input_output_controller_1_output : PROCESS (is_input_output_controller, PC_In_unsigned, port_unsigned, OUT_instr, ADC_N_unsigned, 
      ind_unsigned, write_ram_reg, data_ram_reg, addr_ram_reg, ready_reg, DAC_reg, ind_next_reg)
    VARIABLE guard1 : std_logic;
  BEGIN
    is_input_output_controller_next <= is_input_output_controller;
    write_ram_reg_next <= write_ram_reg;
    data_ram_reg_next <= data_ram_reg;
    addr_ram_reg_next <= addr_ram_reg;
    ready_reg_next <= ready_reg;
    DAC_reg_next <= DAC_reg;
    ind_next_reg_next <= ind_next_reg;
    guard1 := '0';

    CASE is_input_output_controller IS
      WHEN IN_DAC =>
        IF ADC_N_unsigned = 10 THEN 
          DAC_reg_next(0) <= PC_In_unsigned(0);
          DAC_reg_next(1) <= PC_In_unsigned(1);
          DAC_reg_next(2) <= PC_In_unsigned(2);
          DAC_reg_next(3) <= PC_In_unsigned(3);
          guard1 := '1';
        ELSIF ADC_N_unsigned = 11 THEN 
          DAC_reg_next(4) <= PC_In_unsigned(0);
          DAC_reg_next(5) <= PC_In_unsigned(1);
          DAC_reg_next(6) <= PC_In_unsigned(2);
          DAC_reg_next(7) <= PC_In_unsigned(3);
          guard1 := '1';
        END IF;
      WHEN IN_IN_Wait10 =>
        is_input_output_controller_next <= IN_Receive;
      WHEN IN_OUT_Wait =>
        IF ind_unsigned = 4 THEN 
          write_ram_reg_next <= '0';
          ready_reg_next <= '1';
          is_input_output_controller_next <= IN_Wait4;
        ELSE 
          addr_ram_reg_next <= addr_ram_reg + 1;
          data_ram_reg_next <= PC_In_unsigned(to_integer(ind_unsigned));
          ind_next_reg_next <= ind_unsigned + 1;
          is_input_output_controller_next <= IN_OUT_Wait;
        END IF;
      WHEN IN_Receive =>
        IF OUT_instr = '1' THEN 
          ready_reg_next <= '0';
          is_input_output_controller_next <= IN_Wait;
        END IF;
      WHEN IN_Wait =>
        IF ADC_N_unsigned >= 10 THEN 
          is_input_output_controller_next <= IN_DAC;
        ELSE 
          addr_ram_reg_next <= resize(port_unsigned, 14);
          write_ram_reg_next <= '1';
          data_ram_reg_next <= PC_In_unsigned(0);
          ind_next_reg_next <= to_unsigned(0, 5);
          is_input_output_controller_next <= IN_OUT_Wait;
        END IF;
      WHEN IN_Wait4 =>
        ready_reg_next <= '0';
        is_input_output_controller_next <= IN_IN_Wait10;
      WHEN OTHERS => 
        is_input_output_controller_next <= IN_Receive;
    END CASE;

    IF guard1 = '1' THEN 
      ready_reg_next <= '1';
      is_input_output_controller_next <= IN_Wait4;
    END IF;
  END PROCESS input_output_controller_1_output;

  write_ram <= write_ram_reg_next;
  data_ram_tmp <= data_ram_reg_next;
  addr_ram_tmp <= addr_ram_reg_next;
  ready <= ready_reg_next;
  DAC_tmp <= DAC_reg_next;
  ind_next_tmp <= ind_next_reg_next;

  data_ram <= std_logic_vector(data_ram_tmp);

  addr_ram <= std_logic_vector(addr_ram_tmp);

  outputgen: FOR k IN 0 TO 7 GENERATE
    DAC(k) <= std_logic_vector(DAC_tmp(k));
  END GENERATE;

  ind_next <= std_logic_vector(ind_next_tmp);

END rtl;

