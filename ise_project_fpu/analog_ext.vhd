-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_FPU\ise_project_fpu\analog_ext.vhd
-- Created: 2013-04-29 19:25:11
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: analog_ext
-- Source Path: analog_ext
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY analog_ext IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        Model_Tick                        :   IN    std_logic;
        dout                              :   IN    std_logic;
        daca_e                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        daca_f                            :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24
        dacb_e                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
        dacb_f                            :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24
        sig_buf_i                         :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
        sig1_buf_i                        :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
        daca_i                            :   IN    std_logic_vector(0 TO 11);  -- boolean [12]
        dacb_i                            :   IN    std_logic_vector(0 TO 11);  -- boolean [12]
        daca_s                            :   IN    std_logic;
        dacb_s                            :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        CS_low                            :   OUT   std_logic_vector(2 DOWNTO 0);  -- ufix3
        clk_out                           :   OUT   std_logic;
        sig                               :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        sig1                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        dsdi                              :   OUT   std_logic;
        sig_buf_o                         :   OUT   std_logic_vector(0 TO 11);  -- boolean [12]
        sig1_buf_o                        :   OUT   std_logic_vector(0 TO 11);  -- boolean [12]
        daca_o                            :   OUT   std_logic_vector(11 DOWNTO 0);  -- ufix12
        dacb_o                            :   OUT   std_logic_vector(11 DOWNTO 0)  -- ufix12
        );
END analog_ext;


ARCHITECTURE rtl OF analog_ext IS

  -- Component Declarations
  COMPONENT Int_to_Single1
    PORT( u                               :   IN    std_logic_vector(11 DOWNTO 0);  -- ufix12
          y                               :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
          );
  END COMPONENT;

  COMPONENT Enabled_Subsystem
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic;
          Enable                          :   IN    std_logic;
          Out1                            :   OUT   std_logic_vector(0 TO 11)  -- boolean [12]
          );
  END COMPONENT;

  COMPONENT Output_register
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          data                            :   IN    std_logic_vector(0 TO 11);  -- boolean [12]
          trig1                           :   IN    std_logic;
          trig2                           :   IN    real;  -- double
          Out1                            :   OUT   std_logic_vector(0 TO 11);  -- boolean [12]
          Out2                            :   OUT   std_logic_vector(0 TO 11)  -- boolean [12]
          );
  END COMPONENT;

  COMPONENT Single_to_Uint
    PORT( sig                             :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          exp                             :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          frac1                           :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24
          y                               :   OUT   std_logic_vector(11 DOWNTO 0)  -- ufix12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Int_to_Single1
    USE ENTITY work.Int_to_Single1(rtl);

  FOR ALL : Enabled_Subsystem
    USE ENTITY work.Enabled_Subsystem(rtl);

  FOR ALL : Output_register
    USE ENTITY work.Output_register(rtl);

  FOR ALL : Single_to_Uint
    USE ENTITY work.Single_to_Uint(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Counter_Limited_count            : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_Limited_out1             : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL alpha1_MHz_tick_out1             : std_logic;
  SIGNAL alpha1_MHz_tick_out1_1           : std_logic;
  SIGNAL CLK_level6_out1                  : std_logic;
  SIGNAL Logical_Operator8_out1           : std_logic;
  SIGNAL nocs2_out1                       : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL CLK_level1_out1                  : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL Add_add_cast                     : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL Add_add_temp                     : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL Add_out1                         : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL Switch1_out1                     : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Compare_To_Constant1_out1        : std_logic;
  SIGNAL Compare_To_Constant_out1_1       : std_logic;
  SIGNAL nocs_out1                        : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL nocs3_out1                       : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Switch4_out1                     : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL Int_to_Single1_out1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Int_to_Single2_out1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL TmpGroundAtdsdiInport1_out1      : std_logic;
  SIGNAL Compare_To_Constant3_out1        : std_logic;
  SIGNAL CLK_level7_out1                  : std_logic;
  SIGNAL CLK_level7_out1_1                : std_logic;
  SIGNAL alpha1_MHz_tick_out1_2           : std_logic;
  SIGNAL Logical_Operator7_out1           : std_logic;
  SIGNAL Enabled_Subsystem_out1           : std_logic_vector(0 TO 11);  -- boolean [12]
  SIGNAL Compare_To_Constant2_out1        : std_logic;
  SIGNAL TmpGroundAtOutput_registerInport3_out1 : real := 0.0;  -- double
  SIGNAL Output_register_out1             : std_logic_vector(0 TO 11);  -- boolean [12]
  SIGNAL Output_register_out2             : std_logic_vector(0 TO 11);  -- boolean [12]
  SIGNAL Data_Type_Conversion_out1        : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Single_to_Uint_out1              : std_logic_vector(11 DOWNTO 0);  -- ufix12
  SIGNAL Data_Type_Conversion1_out1       : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Single_to_Uint1_out1             : std_logic_vector(11 DOWNTO 0);  -- ufix12
  SIGNAL Constant_out1                    : std_logic_vector(0 TO 3);  -- boolean [4]
  SIGNAL Constant1_out1                   : std_logic_vector(0 TO 3);  -- boolean [4]

BEGIN
  u_Int_to_Single1 : Int_to_Single1
    PORT MAP( u => sig_buf_i,  -- ufix12
              y => Int_to_Single1_out1  -- uint32
              );

  u_Int_to_Single2 : Int_to_Single1
    PORT MAP( u => sig1_buf_i,  -- ufix12
              y => Int_to_Single2_out1  -- uint32
              );

  u_Enabled_Subsystem : Enabled_Subsystem
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => dout,
              Enable => Logical_Operator7_out1,
              Out1 => Enabled_Subsystem_out1  -- boolean [12]
              );

  u_Output_register : Output_register
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              data => Enabled_Subsystem_out1,  -- boolean [12]
              trig1 => Compare_To_Constant2_out1,
              trig2 => TmpGroundAtOutput_registerInport3_out1,  -- double
              Out1 => Output_register_out1,  -- boolean [12]
              Out2 => Output_register_out2  -- boolean [12]
              );

  u_Single_to_Uint : Single_to_Uint
    PORT MAP( sig => std_logic_vector(Data_Type_Conversion_out1),  -- uint8
              exp => daca_e,  -- uint8
              frac1 => daca_f,  -- ufix24
              y => Single_to_Uint_out1  -- ufix12
              );

  u_Single_to_Uint1 : Single_to_Uint
    PORT MAP( sig => std_logic_vector(Data_Type_Conversion1_out1),  -- uint8
              exp => dacb_e,  -- uint8
              frac1 => dacb_f,  -- ufix24
              y => Single_to_Uint1_out1  -- ufix12
              );

  enb <= clk_enable;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 500
  Counter_Limited_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Counter_Limited_count <= to_unsigned(0, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Counter_Limited_count = 500 THEN 
          Counter_Limited_count <= to_unsigned(0, 16);
        ELSE 
          Counter_Limited_count <= Counter_Limited_count + 1;
        END IF;
      END IF;
    END IF;
  END PROCESS Counter_Limited_process;

  Counter_Limited_out1 <= Counter_Limited_count;

  
  alpha1_MHz_tick_out1 <= '1' WHEN Counter_Limited_out1 >= 250 ELSE
      '0';

  alpha1_MHz_tick_out1_1 <=  NOT alpha1_MHz_tick_out1;

  CLK_level6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      CLK_level6_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        CLK_level6_out1 <= alpha1_MHz_tick_out1;
      END IF;
    END IF;
  END PROCESS CLK_level6_process;


  Logical_Operator8_out1 <= alpha1_MHz_tick_out1_1 AND CLK_level6_out1;

  nocs2_out1 <= to_unsigned(0, 7);

  Add_add_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & Logical_Operator8_out1;
  Add_add_temp <= Add_add_cast + resize(CLK_level1_out1, 32);
  
  Add_out1 <= "1111111" WHEN Add_add_temp(31 DOWNTO 7) /= "0000000000000000000000000" ELSE
      Add_add_temp(6 DOWNTO 0);

  
  Switch1_out1 <= Add_out1 WHEN Model_Tick = '0' ELSE
      nocs2_out1;

  CLK_level1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      CLK_level1_out1 <= to_unsigned(0, 7);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        CLK_level1_out1 <= Switch1_out1;
      END IF;
    END IF;
  END PROCESS CLK_level1_process;


  
  Compare_To_Constant_out1 <= '1' WHEN CLK_level1_out1 >= 1 ELSE
      '0';

  
  Compare_To_Constant1_out1 <= '1' WHEN CLK_level1_out1 <= 15 ELSE
      '0';

  Compare_To_Constant_out1_1 <= Compare_To_Constant_out1 AND Compare_To_Constant1_out1;

  nocs_out1 <= to_unsigned(0, 3);

  nocs3_out1 <= to_unsigned(6, 3);

  
  Switch4_out1 <= nocs_out1 WHEN Compare_To_Constant_out1_1 = '0' ELSE
      nocs3_out1;

  CS_low <= std_logic_vector(Switch4_out1);

  clk_out <= alpha1_MHz_tick_out1;

  sig <= Int_to_Single1_out1;

  sig1 <= Int_to_Single2_out1;

  TmpGroundAtdsdiInport1_out1 <= '0';

  dsdi <= TmpGroundAtdsdiInport1_out1;

  
  Compare_To_Constant3_out1 <= '1' WHEN CLK_level1_out1 >= 3 ELSE
      '0';

  CLK_level7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      CLK_level7_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        CLK_level7_out1 <= alpha1_MHz_tick_out1;
      END IF;
    END IF;
  END PROCESS CLK_level7_process;


  CLK_level7_out1_1 <=  NOT CLK_level7_out1;

  alpha1_MHz_tick_out1_2 <= alpha1_MHz_tick_out1 AND CLK_level7_out1_1;

  Logical_Operator7_out1 <= alpha1_MHz_tick_out1_2 AND (Compare_To_Constant_out1_1 AND Compare_To_Constant3_out1);

  
  Compare_To_Constant2_out1 <= '1' WHEN CLK_level1_out1 = 16 ELSE
      '0';

  TmpGroundAtOutput_registerInport3_out1 <= 0.0;

  sig_buf_o <= Output_register_out1;

  sig1_buf_o <= Output_register_out2;

  Data_Type_Conversion_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & daca_s;

  daca_o <= Single_to_Uint_out1;

  Data_Type_Conversion1_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & dacb_s;

  dacb_o <= Single_to_Uint1_out1;

  ce_out <= clk_enable;

  Constant_out1(0) <= '0';
  Constant_out1(1) <= '0';
  Constant_out1(2) <= '0';
  Constant_out1(3) <= '1';

  Constant1_out1(0) <= '1';
  Constant1_out1(1) <= '0';
  Constant1_out1(2) <= '0';
  Constant1_out1(3) <= '1';

END rtl;

