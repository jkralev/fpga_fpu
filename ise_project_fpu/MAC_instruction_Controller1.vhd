-- -------------------------------------------------------------
-- 
-- File Name: D:\Dan\FPGA_Test\ise_project_1\MAC_instruction_Controller1.vhd
-- Created: 2012-11-05 22:45:21
-- 
-- Generated by MATLAB 7.11 and Simulink HDL Coder 2.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: MAC_instruction_Controller1
-- Source Path: ss_controller/Forward speed tracking/MAC instruction Controller1
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ss_controller_pkg.ALL;

ENTITY MAC_instruction_Controller1 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        sys                               :   IN    vector_of_std_logic_vector32(0 TO 4);  -- sfix32_En20 [5]
        xu                                :   IN    vector_of_std_logic_vector32(0 TO 4);  -- sfix32_En20 [5]
        result                            :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
        Model_Tick                        :   IN    std_logic;
        mul1                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
        mul2                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En20
        reset_1                           :   OUT   std_logic;
        xy                                :   OUT   vector_of_std_logic_vector32(0 TO 3)  -- sfix32_En20 [4]
        );
END MAC_instruction_Controller1;


ARCHITECTURE rtl OF MAC_instruction_Controller1 IS

  -- Signals
  SIGNAL sys_signed                       : vector_of_signed32(0 TO 4);  -- sfix32_En20 [5]
  SIGNAL xu_signed                        : vector_of_signed32(0 TO 4);  -- sfix32_En20 [5]
  SIGNAL result_signed                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL is_MAC_instruction_Controller1   : T_state_type_is_MAC_instruction_Controller11;  -- uint8
  SIGNAL mul1_tmp                         : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL mul2_tmp                         : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL xy_tmp                           : vector_of_signed32(0 TO 3);  -- sfix32_En20 [4]
  SIGNAL mul1_reg                         : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL mul2_reg                         : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL reset_reg                        : std_logic;
  SIGNAL xy_reg                           : vector_of_signed32(0 TO 3);  -- sfix32_En20 [4]
  SIGNAL is_MAC_instruction_Controller1_next : T_state_type_is_MAC_instruction_Controller11;  -- enumerated type (8 enums)
  SIGNAL mul1_reg_next                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL mul2_reg_next                    : signed(31 DOWNTO 0);  -- sfix32_En20
  SIGNAL reset_reg_next                   : std_logic;
  SIGNAL xy_reg_next                      : vector_of_signed32(0 TO 3);  -- sfix32_En20 [4]

BEGIN
  outputgen2: FOR k IN 0 TO 4 GENERATE
    sys_signed(k) <= signed(sys(k));
  END GENERATE;

  outputgen1: FOR k IN 0 TO 4 GENERATE
    xu_signed(k) <= signed(xu(k));
  END GENERATE;

  result_signed <= signed(result);

  MAC_instruction_Controller1_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mul1_reg <= to_signed(0, 32);
      mul2_reg <= to_signed(0, 32);
      reset_reg <= '0';
      xy_reg <= (OTHERS => to_signed(0, 32));
      is_MAC_instruction_Controller1 <= IN_wait_r;
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        is_MAC_instruction_Controller1 <= is_MAC_instruction_Controller1_next;
        mul1_reg <= mul1_reg_next;
        mul2_reg <= mul2_reg_next;
        reset_reg <= reset_reg_next;
        xy_reg <= xy_reg_next;
      END IF;
    END IF;
  END PROCESS MAC_instruction_Controller1_1_process;

  MAC_instruction_Controller1_1_output : PROCESS (is_MAC_instruction_Controller1, sys_signed, xu_signed, result_signed, Model_Tick, 
      mul1_reg, mul2_reg, reset_reg, xy_reg)
  BEGIN
    is_MAC_instruction_Controller1_next <= is_MAC_instruction_Controller1;
    mul1_reg_next <= mul1_reg;
    mul2_reg_next <= mul2_reg;
    reset_reg_next <= reset_reg;
    xy_reg_next <= xy_reg;

    CASE is_MAC_instruction_Controller1 IS
      WHEN IN_calc1 =>
        mul1_reg_next <= sys_signed(1);
        mul2_reg_next <= xu_signed(1);
        is_MAC_instruction_Controller1_next <= IN_calc2;
      WHEN IN_calc2 =>
        mul1_reg_next <= sys_signed(2);
        mul2_reg_next <= xu_signed(2);
        is_MAC_instruction_Controller1_next <= IN_calc3;
      WHEN IN_calc3 =>
        mul1_reg_next <= sys_signed(3);
        mul2_reg_next <= xu_signed(3);
        is_MAC_instruction_Controller1_next <= IN_calc4;
      WHEN IN_calc4 =>
        mul1_reg_next <= sys_signed(4);
        mul2_reg_next <= xu_signed(4);
        is_MAC_instruction_Controller1_next <= IN_calc5;
      WHEN IN_calc5 =>
        xy_reg_next(0) <= result_signed;
        xy_reg_next(1) <= xu_signed(0);
        xy_reg_next(2) <= xu_signed(2);
        xy_reg_next(3) <= xu_signed(3);
        reset_reg_next <= '1';
        is_MAC_instruction_Controller1_next <= IN_resetw;
      WHEN IN_resetw =>
        is_MAC_instruction_Controller1_next <= IN_wait_f;
      WHEN IN_wait_f =>
        IF Model_Tick = '0' THEN 
          is_MAC_instruction_Controller1_next <= IN_wait_r;
        END IF;
      WHEN IN_wait_r =>
        IF Model_Tick = '1' THEN 
          reset_reg_next <= '0';
          mul1_reg_next <= sys_signed(0);
          mul2_reg_next <= xu_signed(0);
          is_MAC_instruction_Controller1_next <= IN_calc1;
        END IF;
      WHEN OTHERS => 
        is_MAC_instruction_Controller1_next <= IN_wait_r;
    END CASE;

  END PROCESS MAC_instruction_Controller1_1_output;

  mul1_tmp <= mul1_reg_next;
  mul2_tmp <= mul2_reg_next;
  reset_1 <= reset_reg_next;
  xy_tmp <= xy_reg_next;

  mul1 <= std_logic_vector(mul1_tmp);

  mul2 <= std_logic_vector(mul2_tmp);

  outputgen: FOR k IN 0 TO 3 GENERATE
    xy(k) <= std_logic_vector(xy_tmp(k));
  END GENERATE;

END rtl;

